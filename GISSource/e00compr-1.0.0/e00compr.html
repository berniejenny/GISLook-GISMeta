<HTML>
<HEADER>
<TITLE>E00compr - Compressed E00 Read/Write Library</TITLE>
</HEADER>
<BODY>
<CENTER>
 <H1>E00compr 1.0</H1>
 <P>
 <H2>Compressed E00 Read/Write Library</H2>
 <P>
 By Daniel Morissette, 
  <A HREF="mailto:dmorissette@dmsolutions.ca">dmorissette@dmsolutions.ca</A>
</CENTER>
 <HR WIDTH=50%>
<CENTER>
<I>The latest version of this documentation and of the whole package can be obtained from <A HREF="http://avce00.maptools.org/">http://avce00.maptools.org/</A></I>
</CENTER>
 <HR WIDTH=50%>

<P>

<H2>Table of Contents</H2>
<P>
<UL>
  <LI><A HREF="#license">Copyright and License terms</a>
  <LI><A HREF="#whatis">What is E00compr?</a>
  <LI><A HREF="#build">Building the package</a>
  <LI><A HREF="#e00conv">Using the 'e00conv' Conversion program</a>
  <LI><A HREF="#howto-lib">How to use the library in your programs</a>
  <LI><A HREF="#libread">Library functions to Read compressed E00 files</a>
  <UL>
    <LI><A HREF="#readexample">Example</a>
    <LI><A HREF="#readptr">E00ReadPtr data type</a>
    <LI><A HREF="#readopen">E00ReadOpen()</a>
    <LI><A HREF="#readopencb">E00ReadCallbackOpen()</a>
    <LI><A HREF="#readclose">E00ReadClose()</a>
    <LI><A HREF="#readnextline">E00ReadNextLine()</a>
    <LI><A HREF="#readrewind">E00ReadRewind()</a>
  </UL>
  <LI><A HREF="#libwrite">Library functions to Write compressed E00 files</a>
  <UL>
    <LI><A HREF="#writeexample">Example</a>
    <LI><A HREF="#writeptr">E00WritePtr data type</a>
    <LI><A HREF="#writeopen">E00WriteOpen()</a>
    <LI><A HREF="#writeopencb">E00WriteCallbackOpen()</a>
    <LI><A HREF="#writeclose">E00WriteClose()</a>
    <LI><A HREF="#writenextline">E00WriteNextLine()</a>
  </UL>
  <LI><A HREF="#errors">Trapping errors reported by the library</a>
  <UL>
    <LI><A HREF="#errsethandler">CPLSetErrorHandler()</a>
    <LI><A HREF="#cplerror">CPLError()</a>
    <LI><A HREF="#errlastno">CPLGetLastErrorNo()</a>
    <LI><A HREF="#errlastmsg">CPLGetLastErrorMsg()</a>
    <LI><A HREF="#errno-read">Errors generated by the library and their
         meaning</a>
  </UL>
</UL>

<P>
<H2><A NAME="license">Copyright and License terms</A></H2>
<P>
The most part of the E00COMPR library is
   Copyright (c) 1998-2005, Daniel Morissette (dmorissette@dmsolutions.ca)
<br>
it also contains portions (CPL lib) that are
   Copyright (c) 1998-1999, Frank Warmerdam (warmerdam@pobox.com)
<p>
The AVCE00 library and the supporting CPL code are freely available under
the following Open Source license terms:
<P>
<CENTER><TABLE WIDTH=90% BORDER=1 CELLPADDING=15><TR><TD>
Copyright (c) 1998-2005, Daniel Morissette
<br>
Copyright (c) 1998-1999, Frank Warmerdam
<P>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
<P>
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
<P>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
</TD></TR></TABLE></CENTER>

<P>
<H2><A NAME="whatis">What is E00compr?</A></H2>
<P>
E00compr is an ANSI C library that reads and writes Arc/Info compressed E00 
files.  Both "PARTIAL" and "FULL" compression levels are supported.
<P>
This package can be divided in three parts:
<UL>
  <LI>The 'e00conv' command-line program.  This program takes a E00 file as 
      input (compressed or not) and copies it to a new file with the requested
      compression level (NONE, PARTIAL or FULL).
  <P>
  <LI>A set of library functions to read compressed E00 files.  These 
      functions read a E00 file (compressed or not) and return a stream of 
      uncompressed lines, making the E00 file appear as if it was not 
      compressed.
  <P>
  <LI>A set of library functions to write compressed E00 files.  These 
      functions take one line after another from what should be a uncompressed
      E00 file, and write them to a file with the requested compression level,
      either NONE, PARTIAL or FULL.
</UL>

<P>
<H2><A NAME="build">Building the package</A></H2>
<P>
The library has already been succesfully built on Windows (with MSVC++ 4 and 5),
and on Linux (with gcc).
<P>
<B>Windows users:</B>
<P>
<UL>
  A MSVC++ 4 makefile (e00compr.mak) to build the 'e00conv.exe' 
  command-line program is included with the distribution.  
  You should have no problem opening this file with MSVC++ and building 
  the package directly.  
  <P>
  MSVC++ 5 will ask you if you want to convert the makefile to
  the new project format.  Answer "Yes" and you should be just fine.
  <P>
  If you are using another development environment, then you will likley need
  to build your own project. Include the following files in your
  project:
  <P>
  <UL>
    e00compr.h<BR>
    e00read.c<BR>
    e00write.c<BR>
   <P>
    cpl_port.h<BR>
    cpl_conv.h<BR>
    cpl_error.h<BR>
    cpl_vsi.h<BR> 
    cpl_conv.c<BR>
    cpl_error.c<BR>
    cpl_vsisimple.c<BR>
  </UL>

</UL>
<P>
<B>Unix users:</B>
<P>
<UL>
  A Makefile is included with the distribution.  Its default target will build
  the 'e00conv' executable using gcc.  Take a look at the definitions at the
  top of the Makefile to see if you need to modify it to build in your own
  environment.
  <P>
  In most cases, building the package should be as simple as extracting the
  distribution files to a empty directory, and then going to this directory
  and typing <CODE>make</CODE>.
  <P>
  If you encounter problems with the Makefile, then make sure that it 
  contains Unix line breaks.  The line breaks are sometimes altered when
  the distribution is copied between PCs and Unix systems, and Make doesn't 
  seem to like Makefiles that contain DOS CR-LF line breaks.
</UL>
<P>
<H2><A NAME="e00conv">Using the 'e00conv' Conversion Program</A></H2>
<P>
'e00conv' is a command-line executable that takes a E00 file as input
(compressed or not) and copies it to a new file with the requested
compression level (NONE, PARTIAL or FULL).
<P>
<UL>
<B><CODE>e00conv &lt;input_file&gt; &lt;output_file&gt; [NONE|PARTIAL|FULL]</CODE></B>
<P>
  <UL>
    <LI><B><CODE>input_file</CODE></B> is the name of the E00 file to read from.
    <P>
    <LI><B><CODE>output_file</CODE></B> is the name of the file to create.  
        If the file already exists then it is overwritten.
    <P>
    <LI>The last argument is optional and specifies the compression level to 
        use when creating the output file (one of NONE, PARTIAL or FULL).
        The default is NONE (uncompressed).
  </UL>
</UL>

<P>
<H2><A NAME="howto-lib">How to use the library in your programs</A></H2>
<P>
<HR WIDTH=50%>
<CENTER>
  Note: If you are not planning to use the library in your programs, <BR>
  then you can stop reading here... <BR>
  the rest of this document won't be of any use to you!
</CENTER>
<HR WIDTH=50%>
<P>
To use the library in your programs, include the file "e00compr.h", and link
with the "e00compr.a" library produced by the Unix Makefile.
<P>
If you are working in a Windows development environment (i.e. with projects,
no Makefiles!) then add all the C files from the distribution to your project,
except "e00conv.c".

<P>
<H2><A NAME="libread">Library functions to Read compressed E00 files</A></H2>
<P>
All the read functions are defined inside "e00read.c".  Information about the
file currently being read is stored inside an internal structure.  You do not
need to understand the contents of this structure to use the library.  
<P>
All you need is to declare a <B><CODE>E00ReadPtr</CODE></B> variable which 
will serve as a handle on the input file for all the other functions.
<P>
You use the following <B>functions</b> to read a E00 file:
<PRE>
    E00ReadPtr  E00ReadOpen(const char *pszFname);
    void        E00ReadClose(E00ReadPtr hInfo);

    const char *E00ReadNextLine(E00ReadPtr hInfo);
    void        E00ReadRewind(E00ReadPtr hInfo);
</PRE>
Each function is described after the example below.
<P>
<H3><A NAME="readexample">Example:</A></H3>
<UL>
This short <B>example</B> uses the library to read a E00 compressed file
("test.e00") and prints the uncompressed result to stdout.
<P>
<PRE>
/**********************************************************************
 *                          ex_read.c
 *
 * This example program illustrates the use of the E00ReadOpen()
 * and associated compressed E00 read functions.
 **********************************************************************/

#include &lt;stdio.h&gt;

#include "e00compr.h"

int main(int argc, char *argv[])
{
    E00ReadPtr  hReadPtr;
    const char  *pszLine;

    /* Open input */
    hReadPtr = E00ReadOpen("test.e00");

    if (hReadPtr)
    {
        /* Read lines from input until we reach EOF */
        while((pszLine = E00ReadNextLine(hReadPtr)) != NULL)
        {
            if (CPLGetLastErrorNo() == 0)
                printf("%s\n", pszLine);
            else
            {
                /* An error happened while reading the last line... */
                break;
            }
        }

        /* Close input file */
        E00ReadClose(hReadPtr);
    }
    else
    {
        /* ERROR ... failed to open input file */
    }

    return 0;
}
  </PRE>
</UL>

<P>
<H3><A NAME="readptr">E00ReadPtr data type</A></H3>
<P>
<UL>
    A variable of type <CODE>E00ReadPtr</CODE> serves as a handle on the
    current input file.
    <P>
    The handle is allocated by <CODE>E00ReadOpen()</CODE>, and you must
    call <CODE>E00ReadClose()</CODE> to properly release the memory associated
    with it.
</UL>
<P>
<H3><A NAME="readopen">E00ReadOpen()</A></H3>
<P>
<UL>
    <CODE>E00ReadPtr  E00ReadOpen(const char *pszFname);</CODE>
    <P>
    Opens a E00 input file and returns a <CODE>E00ReadPtr</CODE> handle.  
    <P>
    The input file can be in
    compressed or uncompressed format.  <CODE>E00ReadClose()</CODE> will
    eventually have to be called to release the returned handle.
    <P>
    Returns NULL if the file could not be opened or if it does not 
    appear to be a valid E00 file.
</UL>
<P>
<H3><A NAME="readopencb">E00ReadCallbackOpen()</A></H3>
<P>
<UL>
    <PRE>
E00ReadPtr  E00ReadCallbackOpen(void *pRefData,
                                const char * (*pfnReadNextLine)(void *),
                                void (*pfnReadRewind)(void *));
</PRE>
    <P>
    This is an alternative to <CODE>E00ReadOpen()</CODE> for cases where 
    you have to
    do all the file management yourself.  You open/close the file yourself
    and provide 2 callback functions: to read from the file and rewind the
    file pointer.
    <P>
    <CODE>pRefData</CODE> is your own handle on the physical file and can
    be whatever you want... it is not used by the library, it will be
    passed directly to your 2 callback functions when they are called.
    <P>
    The callback functions must have the following C prototype:
    <P>
    <PRE>
    const char *myReadNextLine(void *pRefData);
    void        myReadRewind(void *pRefData);
    </PRE>
    <P>
    <UL>
      <CODE>myReadNextLine()</CODE> should return a reference to its own
      internal buffer, or NULL if an error happens or when EOF is reached.
    </UL>
    <P>
    <CODE>E00ReadCallbackOpen()</CODE> returns a E00ReadPtr handle or NULL
    if the file does not appear to be a valid E00 file.
    <P>
    For an example of the use of this method, see the file 
    <A HREF="ex_readcb.c">ex_readcb.c</A> included in the library 
    distribution.
</UL>
<P>
<H3><A NAME="readclose">E00ReadClose()</A></H3>
<P>
<UL>
    <CODE>void        E00ReadClose(E00ReadPtr hInfo);</CODE>
    <P>
    Closes the physical file and releases any memory associated with a 
    <CODE>E00ReadPtr</CODE> handle.
</UL>
<P>
<H3><A NAME="readnextline">E00ReadNextLine()</A></H3>
<P>
<UL>
    <CODE>const char *E00ReadNextLine(E00ReadPtr hInfo);</CODE>
    <P>
    Returns the next line of input from the E00 file in uncompressed form 
    or NULL if we reached EOF or if an error happened.  The returned line
    is a null-terminated string, and it does not include a newline character.
    Call <CODE>CPLGetLastErrorNo()</CODE> after calling
    <CODE>E00ReadNextLine()</CODE> to make sure that the whole line was 
    read succesfully.
    <P>
    Note that <CODE>E00ReadNextLine()</CODE> returns a reference to an
   internal buffer whose contents will
    be valid only until the next call to this function.  The caller should
    not attempt to free() the returned pointer.
</UL>
<P>
<H3><A NAME="readrewind">E00ReadRewind()</A></H3>
<P>
<UL>
    <CODE>void        E00ReadRewind(E00ReadPtr hInfo);</CODE>
    <P>
    Rewinds the E00ReadPtr just like the stdio <CODE>rewind()</CODE> function
    would do.
    <P>
    Useful when you have to do multiple read passes on the same input file.
</UL>

<P>
<H2><A NAME="libwrite">Library functions to Write compressed E00 files</A></H2>
<P>
The write functions are defined inside "e00write.c".  The information about 
the file currently being written is stored inside an internal structure.  
As for the read library, you do not need to understand the contents of this
structure to use the library.
<P>
Your program has to declare a <B><CODE>E00WritePtr</CODE></B> variable 
which will serve as a handle on the output file for all the other functions.
<P>
You use the following <B>functions</b> to write a E00 file:
<PRE>
    E00WritePtr E00WriteOpen(const char *pszFname, int nComprLevel);
    void        E00WriteClose(E00WritePtr hInfo);

    int		E00WriteNextLine(E00WritePtr hInfo, const char *pszLine);
</PRE>
Each function is described after the example below.
<P>
<H3><A NAME="writeexample">Example:</A></H3>
<UL>
This <B>example</B> is a simpler version of the "e00conv.c" program that
is included with this distribution.  It uses the read library to read a E00
file ("test1.e00") and uses the write library to copy its contents one line
at a time to a new E00 file ("test2.e00") with FULL compression:
<P>
<PRE>
/**********************************************************************
 *                          ex_write.c
 *
 * This example program illustrates the use of the E00WriteOpen()
 * and associated compressed E00 write functions.
 **********************************************************************/
#include &lt;stdio.h&gt;

#include "e00compr.h"

int main(int argc, char *argv[])
{
    E00ReadPtr  hReadPtr;
    E00WritePtr hWritePtr;
    const char  *pszLine;
    int         nStatus = 0;

    /* Open input file */
    hReadPtr = E00ReadOpen("test1.e00");

    if (hReadPtr)
    {
        /* Open output file */
        hWritePtr = E00WriteOpen("test2.e00", E00_COMPR_FULL);

        if (hWritePtr)
        {
            /* Read lines from input until we reach EOF */
            while((pszLine = E00ReadNextLine(hReadPtr)) != NULL)
            {
                if ((nStatus = CPLGetLastErrorNo()) == 0)
                    nStatus = E00WriteNextLine(hWritePtr, pszLine);

                if (nStatus != 0)
                {
                    /* An error happened while converting the last 
                     * line... abort*/
                    break;
                }
            }
            /* Close output file. */
            E00WriteClose(hWritePtr);
        }
        else
        {
            /* ERROR ... failed to open output file */
            nStatus = CPLGetLastErrorNo();
        }

        /* Close input file. */
        E00ReadClose(hReadPtr);
    }
    else
    {
        /* ERROR ... failed to open input file */
        nStatus = CPLGetLastErrorNo();
    }

    return nStatus;
}
</PRE>
</UL>

<P>
<H3><A NAME="writeptr">E00WritePtr data type</A></H3>
<P>
<UL>
    A variable of type <CODE>E00WritePtr</CODE> serves as a handle on the
    current input file.
    <P>
    The handle is allocated by <CODE>E00WriteOpen()</CODE>, and you must
    call <CODE>E00WriteClose()</CODE> to properly release the memory associated
    with it.
</UL>
<P>
<H3><A NAME="writeopen">E00WriteOpen()</A></H3>
<P>
<UL>
    <CODE>E00WritePtr  E00WriteOpen(const char *pszFname, int nComprLevel);
    </CODE>
    <P>
    Creates a new E00 file for output with the specified compression level,
    and returns a <CODE>E00WritePtr</CODE> handle for it.  If the file 
    already exists, then it is overwritten.
    <P>
    <CODE>nComprLevel</CODE> is one of Arc/Info's 3 levels
    of compression:
    <P>
    <UL>
      <LI>E00_COMPR_NONE - creates an uncompressed file.
      <LI>E00_COMPR_PARTIAL - creates a file with PARTIAL compression.
      <LI>E00_COMPR_FULL - creates a file with FULL compression.
    </UL>
    <P>
    Returns NULL if the file could not be opened.
</UL>
<P>
<H3><A NAME="writeopencb">E00WriteCallbackOpen()</A></H3>
<P>
<UL>
<PRE>
E00WritePtr E00WriteCallbackOpen(void *pRefData,
                                 int (*pfnWriteNextLine)(void *, const char *),
                                 int nComprLevel);
</PRE>
  <P>
  This is an alternative to <CODE>E00WriteOpen()</CODE> for cases where 
  you have to
  do all the file management yourself.  You open/close the file yourself
  and provide a callback function to write one line at a time to the
  file.  
  <P>
  <CODE>pRefData</CODE> is your own handle on the physical file and can
  be whatever you want... it is not used by the library, it will be
  passed directly to your callback function when it is called.
  <P>
  The callback function must have the following C prototype:
  <P>
<PRE>
    int    myWriteNextLine(void *pRefData, const char *pszLine);
</PRE>
   <UL>
   <P>
    <CODE>myWriteNextLine()</CODE> should return a 
    positive value on success (the number of chars written, like printf() 
    does) or -1 if an error happened.
    <P>
    The value passed by the library in pszLine is not terminated
    by a '\n' character... it is assumed that your 
    <CODE>myWriteNextLine()</CODE> implementation will take care of 
    terminating the line with a '\n' if necessary.
    <P>
  </UL>
    <CODE>nComprLevel</CODE> is one of Arc/Info's 3 levels
    of compression:
    <P>
    <UL>
      <LI>E00_COMPR_NONE - creates an uncompressed file.
      <LI>E00_COMPR_PARTIAL - creates a file with PARTIAL compression.
      <LI>E00_COMPR_FULL - creates a file with FULL compression.
    </UL>
  <P>
  <CODE>E00WriteCallbackOpen()</CODE> returns a new E00ReadWritePtr handle and
  E00WriteClose() will eventually have to be called to release 
  the resources used by the new handle.
  <P>
  For an example of the use of this method, see the file 
  <A HREF="ex_writecb.c">ex_writecb.c</A> included in the library 
  distribution.

</UL>
<P>
<H3><A NAME="writeclose">E00WriteClose()</A></H3>
<P>
<UL>
    <CODE>void        E00WriteClose(E00WritePtr hInfo);</CODE>
    <P>
    Closes the physical file and release any memory associated with a 
    <CODE>E00WritePtr</CODE> handle.
</UL>
<P>

<H3><A NAME="writenextline">E00WriteNextLine()</A></H3>
<P>
<UL>
    <CODE>int         E00WriteNextLine(E00WritePtr hInfo, const char *pszLine);
    </CODE>
    <P>
    Takes the next line of what should be headed to a uncompressed E00 file,
    converts it to the requested compression level, and writes the 
    (compressed) result to the output file.
    <P>
    <CODE>pszLine</CODE> should be a null-terminated string with a maximum
    of 80 characters (E00 lines cannot be longer than 80 characters).  Do NOT
    include a '\n' at the end of the line, it will be added automatically
    by the function if it is needed.
    <P>
    Returns 0 if the line was processed succesfully, or an error number
    (see error codes below) if an error happened.
    <P>
    Note that this function does not do any syntax check on the input you
    provide.  It assumes that what you pass to it is a valid stream of
    E00 lines as they would appear in an uncompressed E00 file.
</UL>

<P>
<H2><A NAME="errors">Trapping errors reported by the library</A></H2>
<P>
When errors happen, the library's default behavior is to report an error
message on stderr, and to fail nicely, usually by simulating a EOF situation.
Errors are reported through the function <CODE>CPLError()</CODE> defined in
"cpl_error.c".
<P>
While this is sufficient for the purposes of the 'e00conv' command-line 
program, you may want to trap and handle errors yourself if you use the 
library in a bigger application (a GUI application for instance).
<P>
<H3><A NAME="errsethandler">CPLSetErrorHandler()</A></H3>
<P>
<UL>
<PRE>
void  CPLSetErrorHandler(void (*pfnErrorHandler)(CPLErr, int, const char *));
</PRE>
    <P>
    You can use <CODE>CPLSetErrorHandler()</CODE> to override the default error
    handler function.  Your new error handler should be a C function with the
    following prototype:
    <P>
    <UL>
<PRE>void MyErrorHandler(CPLErr eErrClass, int err_no, const char *msg);</PRE>
    </UL>
    <P>
    And you register it with the following call at the beginning of your
    program:
    <P>
    <UL><PRE>CPLSetErrorHandler( MyErrorHandler );</PRE>
    </UL>
</UL>

<P>
<H3><A NAME="cplerror">CPLError()</A></H3>
<P>
<UL>
    <PRE>void CPLError(CPLErr eErrClass, int err_no, const char *fmt, ...);</PRE>
    <P>
    The library reports errors through this function.  It's default behavior
    is to display the error messages to stderr, but it can be overridden using
    <CODE>CPLSetErrorHandler()</CODE>.  
    <P>
    You can call <CODE>CPLGetLastErrorNo()</CODE> or 
    <CODE>CPLGetLastErrorMsg()</CODE> to get the last error number and string.
    <P>
    <CODE>eErrClass</CODE> defines the severity of the error:
<PRE>
    typedef enum
    {
        CE_None = 0,
        CE_Log = 1,
        CE_Warning = 2,
        CE_Failure = 3,
        CE_Fatal = 4
    } CPLErr;
</PRE>
    <P>
    Error class CE_Fatal will abort the execution of the program, it is
    mainly used for out of memory errors, or unrecoverable situations of
    that kind.  All the other error classes return control to the calling
    function.
    <P>
</UL>

<P>
<H3><A NAME="errlastno">CPLGetLastErrorNo()</A></H3>
<P>
<UL>
    <PRE>int         CPLGetLastErrorNo();</PRE>
    <P>
    Returns the number of the last error that was produced.  Returns 0 if
    the last library function that was called completed without any error.
    See the list of possible error numbers below.
    <P>
    Note: This function works even if you redefined your own error handler 
    using <CODE>CPLSetErrorHandler()</CODE> .
</UL>
<P>
<H3><A NAME="errlastmsg">CPLGetLastErrorMsg()</A></H3>
<P>
<UL>
    <PRE>const char *CPLGetLastErrorMsg();</PRE>
    <P>
    Returns a reference to a static buffer containing the last error message
    that was produced.  The caller should not attempt to free this buffer.
    Returns an empty string ("") if the last library function that was called
    completed without any error.
    <P>
    Note: This function works even if you redefined your own error handler 
    using <CODE>CPLSetErrorHandler()</CODE> .
</UL>

<P>
<H3><A NAME="errno">Errors generated by the library and their meaning:</A></H3>
<P>
The values for the error codes returned by the library are defined in
the file cpl_error.h.  
<P>
<UL><PRE>
#define CPLE_OutOfMemory		2
#define CPLE_FileIO			3
#define CPLE_OpenFailed			4
#define CPLE_IllegalArg			5
#define CPLE_NotSupported		6
#define CPLE_AssertionFailed		7
</PRE></UL>
<P>
The following errors codes can be returned:
<P>
<CENTER>
<TABLE BORDER=1 WIDTH=90%>
<TR><TH>Error Code</TH><TH>Description</TH></TR>
<TR>
  <TD VALIGN=TOP>0</TD>
  <TD>Success, no error.</TD>
</TR>
<TR>
  <TD VALIGN=TOP>CPLE_OutOfMemory</TD>
  <TD> Memory allocation failed.  This is a fatal
      error, it will abort the program execution.  There is currently no 
      proper way to recover from it.
  </TD>
</TR>
<TR>
  <TD VALIGN=TOP>CPLE_FileIO</TD>
  <TD>Unexpected error reading or writing to a file.  This can also happen
      if an input file is corrupt.
  </TD>
</TR>
<TR>
  <TD VALIGN=TOP>CPLE_OpenFailed</TD>
  <TD>Failed to open the input ou output file.  Check for permissions, disk
      space, etc.
  </TD>
</TR>
<TR>
  <TD VALIGN=TOP>CPLE_IllegalArg<BR>CPLE_AssertionFailed</TD>
  <TD>Illegal argument passed to one of the library's
      functions.  This is a kind of internal error that should not happen
      unless the lib is modified or is not used as it is expected.
  </TD>
</TR>
<TR>
  <TD VALIGN=TOP>CPLE_NotSupported</TD>
  <TD>One of the functions encountered an 
      unsupported/unexpected case in one of the files.  This 
      error can also be a sign that the file is corrupt.
  </TD>
</TR>
</TABLE>
</CENTER>


<P>
<HR>
Last Update: $Date: 2005/09/17 14:50:29 $
<ADDRESS>Daniel Morissette, 
<A HREF="mailto:dmorissette@dmsolutions.ca">dmorissette@dmsolutions.ca</A></ADDRESS>

<!-- $Id: e00compr.html,v 1.12 2005/09/17 14:50:29 daniel Exp $ -->

</BODY>
</HTML>
